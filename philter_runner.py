"""
Philter Runner - Wrapper for Philter V1.0 de-identification pipeline.

Wraps the Philter de-identification tool located in ./philter/
"""

import os
import subprocess
import sys
import tempfile
import shutil
from pathlib import Path
from typing import List, Tuple

# Paths
PHILTER_DIR = Path(__file__).parent / "philter"
DEIDPIPE_SCRIPT = PHILTER_DIR / "deidpipe.py"
DEFAULT_CONFIG = "configs/philter_one2024.json"


def deidentify_text(raw_text: str, config: str = DEFAULT_CONFIG) -> str:
    """
    De-identify a single text string using Philter.

    Args:
        raw_text: The raw text containing PHI to de-identify
        config: Path to Philter config file (relative to philter dir)

    Returns:
        De-identified text string, or error message if processing fails
    """
    # Create temporary directories
    temp_dir = tempfile.mkdtemp(prefix="philter_")
    input_dir = os.path.join(temp_dir, "input")
    output_dir = os.path.join(temp_dir, "output")

    try:
        os.makedirs(input_dir)
        os.makedirs(output_dir)

        # Write input text to a temp file
        input_file = os.path.join(input_dir, "note.txt")
        with open(input_file, 'w', encoding='utf-8') as f:
            f.write(raw_text)

        # Run Philter
        result = subprocess.run(
            [
                sys.executable, str(DEIDPIPE_SCRIPT),
                "-i", input_dir,
                "-o", output_dir,
                "-f", config,
                "-d", "False",  # Don't use de-identified filenames
                "-l", "False",  # Disable logging
            ],
            cwd=str(PHILTER_DIR),
            capture_output=True,
            text=True,
            timeout=120  # 2 minute timeout
        )

        if result.returncode != 0:
            error_msg = result.stderr or result.stdout or "Unknown error"
            return f"Error: Philter failed - {error_msg.strip()}"

        # Read output file
        output_file = os.path.join(output_dir, "note.txt")
        if not os.path.exists(output_file):
            # Check for any output files
            output_files = list(Path(output_dir).glob("*.txt"))
            if output_files:
                output_file = str(output_files[0])
            else:
                return "Error: No output file generated by Philter"

        with open(output_file, 'r', encoding='utf-8') as f:
            deid_text = f.read()

        return deid_text

    except subprocess.TimeoutExpired:
        return "Error: Philter processing timed out"
    except Exception as e:
        return f"Error: {str(e)}"
    finally:
        # Clean up temp directory
        if os.path.exists(temp_dir):
            shutil.rmtree(temp_dir, ignore_errors=True)


def deidentify_directory(
    input_dir: str,
    output_dir: str,
    config: str = DEFAULT_CONFIG
) -> List[Tuple[str, str]]:
    """
    De-identify all .txt files in a directory using Philter.

    Args:
        input_dir: Path to directory containing .txt files with PHI
        output_dir: Path to directory where de-identified files will be saved
        config: Path to Philter config file (relative to philter dir)

    Returns:
        List of (filename, status) tuples indicating success/failure for each file
    """
    results = []

    # Validate input directory
    if not os.path.isdir(input_dir):
        return [("", f"Error: Input directory does not exist: {input_dir}")]

    # Create output directory if needed
    os.makedirs(output_dir, exist_ok=True)

    # Get list of input files
    input_files = list(Path(input_dir).glob("*.txt"))
    if not input_files:
        return [("", "Error: No .txt files found in input directory")]

    try:
        # Run Philter on the entire directory
        result = subprocess.run(
            [
                sys.executable, str(DEIDPIPE_SCRIPT),
                "-i", input_dir,
                "-o", output_dir,
                "-f", config,
                "-d", "False",  # Keep original filenames
                "-l", "False",  # Disable logging
            ],
            cwd=str(PHILTER_DIR),
            capture_output=True,
            text=True,
            timeout=600  # 10 minute timeout for batch
        )

        if result.returncode != 0:
            error_msg = result.stderr or result.stdout or "Unknown error"
            return [("", f"Error: Philter batch processing failed - {error_msg.strip()}")]

        # Check which files were processed successfully
        for input_file in input_files:
            filename = input_file.name
            output_file = Path(output_dir) / filename

            if output_file.exists():
                results.append((filename, "success"))
            else:
                results.append((filename, "failed - no output generated"))

    except subprocess.TimeoutExpired:
        return [("", "Error: Philter batch processing timed out")]
    except Exception as e:
        return [("", f"Error: {str(e)}")]

    return results


def check_philter_installation() -> Tuple[bool, str]:
    """
    Check if Philter is properly installed and accessible.

    Returns:
        Tuple of (is_installed, message)
    """
    if not PHILTER_DIR.exists():
        return False, f"Philter directory not found: {PHILTER_DIR}"

    if not DEIDPIPE_SCRIPT.exists():
        return False, f"deidpipe.py not found: {DEIDPIPE_SCRIPT}"

    config_path = PHILTER_DIR / DEFAULT_CONFIG
    if not config_path.exists():
        return False, f"Default config not found: {config_path}"

    return True, "Philter installation OK"


if __name__ == "__main__":
    print("Philter Runner - De-identification Wrapper")
    print("=" * 60)

    # Check installation
    installed, msg = check_philter_installation()
    print(f"\nInstallation check: {msg}")

    if not installed:
        print("\nPlease ensure Philter is cloned to ./philter/")
        print("  git clone https://github.com/BCHSI/philter-deidstable1_mirror philter")
        exit(1)

    # Test with sample PHI text
    test_text = """Patient John Smith, DOB 01/15/1980, MRN 12345678, was seen by Dr. Jane Doe on January 20, 2025 at UCSF Medical Center. He underwent laparoscopic cholecystectomy for symptomatic cholelithiasis. The cystic duct was identified, clipped, and divided."""

    print("\n" + "=" * 60)
    print("ORIGINAL TEXT (with PHI):")
    print("=" * 60)
    print(test_text)

    print("\n" + "=" * 60)
    print("DE-IDENTIFIED TEXT:")
    print("=" * 60)

    deid_text = deidentify_text(test_text)
    print(deid_text)

    # Show side-by-side comparison
    print("\n" + "=" * 60)
    print("COMPARISON:")
    print("=" * 60)

    original_lines = test_text.split('. ')
    deid_lines = deid_text.split('. ') if not deid_text.startswith("Error") else [deid_text]

    max_lines = max(len(original_lines), len(deid_lines))
    for i in range(max_lines):
        orig = original_lines[i] if i < len(original_lines) else ""
        deid = deid_lines[i] if i < len(deid_lines) else ""
        print(f"\nOriginal: {orig}")
        print(f"De-ID:    {deid}")
